# 未来的功能

## DHT

![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/DHT_en.svg/800px-DHT_en.svg.png)

分布式散列表（distributed hash table，缩写DHT）是分布式计算系统中的一类，用来将一个关键值（key）的集合分散到所有在分布式系统中的节点，并且可以有效地将消息转送到唯一一个拥有查询者提供的关键值的节点（Peers）。这里的节点类似散列表中的存储位置。分布式散列表通常是为了拥有极大节点数量的系统，而且在系统的节点常常会加入或离开（例如网络断线）而设计的。在一个结构性的延展网络（overlay network）中，参加的节点需要与系统中一小部分的节点沟通，这也需要使用分布式散列表。分布式散列表可以用以创建更复杂的服务，例如分布式文件系统、点对点技术文件分享系统、合作的网页缓存、多播、任播、域名系统以及即时通信等。

跟踪器与节点模式在每个节点加入网络的同时，会将他们所拥有的文件列表发送给服务器，这使得服务器可以进行搜索并将结果传回给进行查询的节点。但中央索引服务器让整个系统易受攻击，且有可能造成法律问题。于是，Gnutella和相似的网络采用大量查询模式（flooding query moudle）：每次搜索都会把查询消息广播给网络上所有的节点。虽然这个方式能够防止单点故障问题，但是比起跟踪器节点模式相比极为没效率。Freenet使用了完全分布式系统，但它建置了一套使用经验法则的基于关键值得转送方法（key based routing）。在这个方法中，每个文件与一个关键值相结合，而拥有相似关键值得文件会倾向被相似得节点构成得集合所保管。于是查询消息就可以根据它所提供的关键值被转送到该集合，而不需要经过所有的节点。然后，Freenet并不保证存在网络上的数据在查询时一定会被找到。
分布式散列表为了达到Guntella与Freenet的分散性以及Napster的效率与正确结果，使用了较为结构化的基于关键值的转送方法。不过分布式散列表也有Freenet的缺点，就是只能做精确搜索，而不能提供部分的关键字；但这个功能可以在分布式散列表的上层实做。

BitTorrent使用“分布式散布哈希表”（DHT）来存储“trackerless”种子的同伴联系信息。实际上，每个同伴都成为一个跟踪者，通过UDP实现。

请注意本文档中使用的术语以避免混淆。“对等”是监听实现BitTorrent协议的TCP端口的客户端/服务器。“节点”是监听实现分布式哈希表协议的UDP端口的客户端/服务器。DHT由节点组成，并存储对等点的位置。BitTorrent客户端包括DHT节点，DHT节点用于联系DHT中的其他节点以获取使用BitTorrent协议下载对等点的位置。

每个节点具有被称为“节点ID”的全局唯一标识符。节点ID是从与BitTorrent infohashes相同的160位空间随机选择的。“距离度量”用于比较两个节点ID或节点ID与“散乱”的infohash。节点必须维护包含少数其他节点的联系信息的路由表。随着ID更接近节点自己的ID，路由表变得更加详细。节点了解DHT中的许多其他节点，这些节点的ID与自己“接近”，但只与少数与自己距离很远的ID进行联系。

在Kademlia中，距离度量是XOR，结果被解释为一个无符号整数。距离$$ (A,B) = |A \quad xor \quad B | $$较小的值更接近。

当一个节点想要找到一个torrent的对等点时，它使用距离度量来比较torrent的infohash和它自己的路由表中的节点的ID。然后，使用最接近infohash的ID联系它所知道的节点，并询问当前正在下载torrent的对端的联系信息。如果被联系的节点知道关于该种子的对等体，则该对等体联系信息与该响应一起返回。否则，被联系的节点必须响应其路由表中最接近torrent的infohash的节点的联系信息。原始节点迭代查询更接近目标infohash的节点，直到它找不到任何更近的节点。搜索结束后，

同级查询的返回值包括一个称为“标记”的不透明值。对于一个节点宣布其控制对等体正在下载一个种子，它必须在最近一次查询中显示从同一查询节点收到的令牌。当一个节点试图“宣布”一个洪流时，被查询的节点检查该令牌与查询节点的IP地址。这是为了防止恶意主机注册其他主机。由于令牌只是由查询节点返回到同一节点接收到的令牌，因此未定义实现。令牌在被分配之后必须被接受一段合理的时间。

### 性质

*   离散性：构成系统的节点并没有任何中央式的协调机制。

*   伸缩性：即使有成千上万个节点，系统仍然应该十分有效率。

*   容错性：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度。

要达到以上目标，有一个关键技术：任一节点只需要与系统种的部分节点沟通，一般来说，若系统有n个节点，那么只有$${\displaystyle \Theta (\log n)} $$ 个节点是必须的。因此，当成员改变的时候，只有一部分的工作（例如数据或关键值的发送，散列表的改变等）必须要完成。

有些分布式散列表的设计需求能对抗网络中恶意的节点的安全性，但仍然保留参加节点的匿名性。在其他的点对点系统（特别是文件分享中）较为少见。

最后，分布式散列表必须处理传统分布式系统可能遇到的问题，例如负载平衡，数据完整，以及性能问题（特别是确认转送消息，数据存储及读取等动作能快速完成）。


